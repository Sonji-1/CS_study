# Process / Thread

## 목차

1. 프로세스와 스레드의 정의, 관계
2. 프로세스 관리 방식
3. 프로세스 생명 주기
4. 프로세스 계층 구조

## 프로세스와 스레드의 정의, 관계

### 프로세스 정의

프로세스 : 실행중인 프로그램 + 프로그램 코드를 실행하면서 생기는 결과물(e.g. 사용중인 파일, 대기중인 시그널, 커널 내부 데이터, 프로세서 상태, 물리적 메모리 영역이 할당된 주소 공간, 실행중인 1개 이상의 스레드 정보, 전역 데이터가 저장된 부분 등)

= 작동 중인 프로그램 및 그와 관련된 자원.

(+ 같은 프로그램을 실행하는 둘 이상의 프로세스가 존재할 수도 있고, 여러 프로세스가 한 파일이나 주소 공간 등 자원을 공유할 수 있음)

### 스레드 정의

스레드(실행 중인 스레드) : 프로세스 내부에서 동작하는 객체(개별적인 프로그램 카운터와 프로세스 스택, 프로세스 레지스터 포함).

커널은 이 스레드를 스케줄링.

### 리눅스의 스레드 구현

스레드(= 경량 프로세스)를 이용해 메모리 주소 공간을 공유하는 같은 프로그램 여러 개를 병렬적으로 동시에 실행 가능.

리눅스 커널에서는 별도의 스레드 개념이 없고, 기본적인 프로세스로 모든 스레드를 구현.

- 리눅스의 스레드 : 특정 자원을 다른 프로세스와 공유하는 특별한 프로세스. 다른 OS에서 스레드는 무거운 프로세스에 비해서 가볍고 빠르게 실행 기능을 제공하는 단위지만, 리눅스에서는 다른 프로세스와 자원을 공유하는 프로세스.

각 스레드는 별도의 task_struct 구조체를 가지고 있음(리눅스에선 스레드를 프로세스처럼 간주하므로, 프로세스가 각기 가지고 있는 task_struct를 가지는 것과 그 원리가 같음)

e.g. 4개의 스레드로 구성된 프로세스가 존재한다면,

일반 OS : 하나의 프로세스 서술자가 있고, 이 서술자 내에서 4개의 스레드를 가리키는 정보가 들어있음. 주소 공간이나 사용중인 파일과 같은 공유 자원 정보는 공통 프로세스 서술자에 들어감.

리눅스 : 4개 프로세스로 간주. 4개의 각기 다른 task_struct 구조체 존재. 이 프로세스들은 서로 일부 자원을 공유하도록 설정.

### 프로세스와 스레드의 관계

리눅스는 프로세스와 스레드를 따로 분간하지 않음. 프로세스를 다른 말로 태스크(Task) 라고도 하는데, 커널의 관점에서 프로세스를 지칭할 때 주로 태스크 라고 사용.

## 프로세스 관리 방식

커널은 프로세스 목록을 “태스크 리스트”로 관리.

- 태스크 리스트 : 프로세스 목록을 저장하는 환형 이중 연결 리스트

각 리스트 항목은 <linux/sched.h> 에 저장된 struct task_struct 구조체 형식으로 정의. 이 개체를 “프로세스 서술자” 라고 부름.

- 프로세스 서술자 : 프로세스와 관련된 모든 정보(e.g. 사용중인 파일, 프로세스의 주소공간, 대기중인 시그널, 프로세스의 상태 등)를 담은 구조체.

task_struct 구조체는 객체 재사용 및 캐시 컬러링(캐시된 총 페이지 수를 최대화하기위해, CPU 캐시 관점에서 인접한 빈 페이지를 할당하는 프로세스) 기능을 지원하는 슬랩 할당자(작은 메모리 조각(slab)을 할당하는 동적 메모리 할당자)를 사용해 할당. 

2.6커널 이전에는 task_struct 구조체를 각 프로세스의 커널 스택 끝 부분에 저장

→ x86처럼 레지스터가 적은 아키텍처에서, 프로세스 서술자의 위치를 별도로 저장하는 레지스터 공간을 절약할 수 있기 때문(스택 포인터로 프로세스 서술자의 위치 계산 가능).

→ 이 구조체를 사용하면 어셈블리 코드에서 사용하는 값의 오프셋을 구하기 매우 쉬워짐.

→ 2.6이후부턴 슬랩 할당자를 이용해 동적으로 프로세스 서술자를 만들기때문에 thread_info라는 새 구조체를 스택의 확장 방향에 배치(스택이 아래로 확장되면 스택의 밑에, 위로 확장되면 스택의 위에)

- 이전 x86시대에 사용하던 task_struct 구조체를 현대 버전으로 다시 만든게 thread_info. 프로세스 서술자 + 플래그 등 스레드에 대한 전반적 정보 포함.

x86 시스템의 thread_info 구조체는 <asm/thread_info.h>에 아래와 같이 정의되어 있음(주석으로 내용 추가 필요할 듯)

struct thread_info {

struct task_struct       *task;                 //main task structure

struct exec_donain    *exec_domain;   //execution domain

__u32                         flags;                  //low level flags

__u32                         status;                //process status

__u32                         cpu;                    //cpu

int                              preempt_count; //0→preemptable, <0 → bug

mm_segment_t          addr_limit;         // address limit

struct restart_block    restart_block;    

void                           *system_return; 

int                              uaccess_err;       

};

→ 프로세스 관련 작업을 하는 대부분의 커널 코드는 task_struct 구조체를 사용.

(프로세스 서술자와 커널 스택 그림 pdf p.6 참조)

태스크의 thread_info 구조체는 프로세스 스택의 제일 끝에 할당.

구조체의 task 포인터가 task_struct 구조체를 가리킴

시스템은 프로세스 인식 번호(=PID)라는 고유 값으로 프로세스 구분. PID는 부정형(정해지지 않음) 숫자 값. 보통 실제로는 int형 사용.

PID 최대값 = 시스템에 동시에 존재할 수 있는 프로세스 수(초기 리눅스와 하위호환을 위해 디폴트 32768. 왜 이 숫자인지는 잘 모름. <linux/thread.h> 파일을 통해 400만까지 상향조정 가능).

만약 최댓값 이상으로 번호를 부여할 경우(e.g. 시스템이 오래 구동되면서 여태 만들었던 프로세스 개수의 합계가 설정된 최댓값을 넘을 경우), 다시 낮은 숫자부터 PID값 할당. 이렇게 되면 나중에 만든 프로세스가 더 큰 PID값을 가진다는 유용성이 사라짐( PID_2 > PID_1이면, PID_2가 나중에 만들어짐)

하위호환이 필요없으면 시스템 관리자가 /proc/sys/kernel/pid_max 값을 수정해 상향 가능. (위 <linux/thread.h>는 이 파일을 수정하는 것으로 추정)

- current 매크로 : 현재 실행중인 태스크의 프로세스 서술자를 빠르게 찾는 방법

방식은 크게 2가지로 나누는데, 각각 아래와 같음.

1. 현재 실행중인 프로세스의 task_struct 포인터를 레지스터에 저장하고 접근
    
    → IBM의 RISC기반 PowerPC에서 이 방식 사용. r2 레지스터에 저장. 프로세스 서술자를 많이 찾으므로 레지스터에 올려 찾으므로 이득을 취함.
    
2. (x86에서)thread_info 구조체가 커널 스택에 저장되므로, 이 구조체의 위치를 찾아 task_struct의 위치 계산.
    
    → x86의 current 매크로는 스택 포인터의 하위 13비트를 덮어써서 thread_info의 위치 계산. current_thread_info()가 이 역할 담당. 여기서 task 항목을 참조하고 task_struct 구조체 반환
    
    코드 예시 : current_thread_info()→task;
    

### 프로세스 상태 전이

프로세스 상태는 프로세스 서술자의 state에 저장되고, 정확히 5개 상태 중 하나가 명시됨.

(Pdf p.8 참조)

- TASK_RUNNING : 프로세스가 실행 가능한 상태. 실행중이거나, 대기열에 적재되어있음.
- TASK_INTERRUPTIBLE : 프로세스가 특정 조건 발생을 대기중(= 중단).  시그널을 받으면 조건에 상관없이 실행 가능한 상태로 전이.
- TASK_UNINTERRUPTIBLE : 시그널을 받아도 실행 가능 상태로 바뀌지 않음. 방해받지 않고 특정 조건을 기다릴 때나, 기다리는 조건이 금방 발생할 때 사용(이 상태는 시그널에 아예 응답 안함)
- TASK_TRACED : 디버거 등 다른 프로세스가 ptrace를 통해 이 프로세스를 추적하는 상태(set되면 추적당하고 있다는 의미)
- TASK_STOPPED : 프로세스 실행이 정지된 상태. (실행중, 실행가능 둘 다 아님) SIGSTOP, SGTSTP, SIGTTIN, SITRROU 시그널을 받거나, 디버그 중 시그널을 받으면 이 상태로 전이.

만약 커널 코드에서 프로세스의 상태를 바꿔야 할 경우, 아래 함수로 변경

set_task_state(task, state); // 태스크 ‘task’ 의 상태를 ‘state’ 상태로 설정

이 함수는 메모리 보호 기능(이게 뭐고 어떻게 하는건지?)을 이용해 다른 프로세서와 작업 순서가 겹치는 것을 방지

### 프로세스 동작 모드

프로세스는 프로그램 코드를 담고 있는데, 실행 파일에서 이 코드를 읽고 프로그램의 주소공간에서 이를 실행. 보통 이 작업은 유저 공간에서 이루어지는데, 프로그램이 시스템 콜을 호출하거나 예외 처리가 발생한 경우, 프로그램은 커널 모드로 진입(아래 그림처럼). 이를 “커널이 프로세스를 대신해 실행중” 이라고 하거나, “커널이 프로세스 컨텍스트에 있다” 라고 말함. 커널에서 작업이 끝나면 다시 유저 모드로 돌아감.

프로세스 컨텍스트에 있을 땐 current 매크로를 사용할 수 있음(프로세스 컨택스트란? : 프로세스가 스케줄링될 수 있는 상태).

프로세스는 시스템 호출 / 예외 처리기 2가지 인터페이스 중 하나로 커널에 진입. 

![Untitled](Untitled.png)

## 프로세스 계층 구조

UNIX시스템에는 프로세스간 계층 구조가 존재. 가장 최상단엔 PID가 1인 init 프로세스가 있음. 모든 프로세스는 이 init 프로세스의 자손. 

- init process : init 부트 과정의 최종 단계에서 커널이 실행하는 프로세스. 시스템의 초기화 스크립트를 읽어 더 많은 프로그램을 실행시킴으로써 부트 과정을 완료하는 프로세스.

시스템의 모든 프로세스는 딱 1개의 부모 프로세스를 가지고, 모든 프로세스는 하나 이상의 자식 프로세스를 가질 수 있음. (부모 : 자식 = 1 : n) 이 프로세스들의 관계는 프로세스 서술자에 저장됨.

task_struct 구조체 안에는 부모의 task_struct 를 가리키는 parent 포인터, 자식의 task_struct를 가리키는 children 포인터가 있음.

- 부모 프로세스의 task_struct를 아는 방법
    
    struct task_struct *my_parent = current→parent;
    
- 자식 프로세스들의 task_struct를 아는 방법
    
    struct task-struct *task;
    
    struct list_head *list;
    
    list_for_each(lists, &current→children) {
    
    task = list_entry(list, struct task_struct, sibling);
    
    }
    
- 어떤 프로세스도 동작할 수 있는 init 프로세스 찾는 방법
    
    struct task_struct *task;
    
    for(task = current; task ! = &init_task; task = task→parent)
    
    ;
    
    →최상위 init 프로세스에 도달할 때 까지 부모 프로세스의 조상을 찾아감.
    

모든 프로세스는 계층 구조를 이루고 있으므로, 이를 이용하면 시스템의 어떤 프로세스도 다른 특정 프로세스를 찾을 수 있음. 단순히 시스템의 모든 프로세스를 훑고 싶을 때는, 작업 리스트 자료구조(환형 이중 연결 리스트)의 특성을 이용해 단순 탐색 가능

- 리스트에서 다음 태스크를 찾는 방법
    
    list_entry(task→tasks.next, struct task_struct, tasks)
    
- 리스트에서 이전 태스크를 찾는 방법
    
    list_entry(task→tasks.prev, struct task_struct, tasks)
    
- 전체 태스크 리스트를 열거하는 방법(매크로 존재)
    
    struct task_struct *task;
    
    for_each_process(task) {
    
    printk(”%s[%d]\n”, task→comm, task→pid);
    
    }
    

## 프로세스 생명주기

프로세스는 fork()로 생성(대개 fork()직후 다른 새 프로그램 실행), exec() 로 실행할 프로그램 할당, exit() 로 종료.

### 프로세스 생성(fork)

대부분 운영체제는 spawn 방식을 사용해서 새 주소공간에 새 프로세스를 만들고, 실행 파일을 읽고 그 코드를 실행함. 유닉스는 fork(), exec()의 두 함수로 분리해서 spawn 방식을 실행.

fork()는 현재 태스크를 복제해 자식 프로세스를 만듦. exec()는 새 실행파일을 주소 공간에 불러오고 이를 실행함.

리눅스에서는 fork()함수를 구현할 때 copy-on-write 방식을 사용해서 구현.

- copy-on-write : 프로세스 주소 공간을 복사하는 대신, 부모와 자식 프로세스가 같은 공간을 공유하는 방식. 리소스 복사는 해당 리소스에 대한 기록이 발생하는 경우에만 동작. 기록이 생기지 않으면 복사를 안하므로, 데이터 복사를 지연 또는 방지.

때문에 COW방식으로 구현된 fork() 함수는 부모 프로세스의 페이지 테이블을 복사하고, 자식 프로세스용 프로세스 서술자를 만들어주면 끝.

- 페이지 테이블 : ?

리눅스에서는 clone()시스템 콜을 이용해 fork()를 구현. 

- clone() 시스템 콜 : 여러 플래그를 사용해 부모와 자식 프로세스간 공유가 필요한 자원 지정.(리눅스의 스레드 구현 절 참고)

실제 프로세스 생성 작업은 kernel/fork.c에 정의된 do_fork()함수에서 처리. 이 함수는 copy_process()함수를 호출하고 프로세스 실행을 시작. 이 copy_process()의 동작은 아래와 같음.

1. dup_task_struct() 함수를 호출해서 커널 스택을 새로 만들고, 새 프로세스용 thread_info, task_struct 구조체 생성(이 시점에서 부모와 자식 프로세스 서술자는 서로 같음)
2. 현재 사용자의 프로세스 개수 제한을 넘어가지 않는지 확인
3. 자식 프로세스 서술자의 여러 값 초기화
4. 자식 프로세스 상태를 TASK_UNINTERRUPTIBLE로 설정, 아직 실행되지 않게 방지.
5. copy_flags() 함수를 호출해 task_struct 구조체의 flags 내용 정리.(e.g. 작업이 관리자 권한을 가지고 있단 의미에서 PF_SUPERRIV 플래그 초기화, 프로세스가 아직 exec()함수를 호출하지 않았단 뜻에서 PF_FORKNOEXEC  플래그 설정)
6. 새로만든 태스크에 새 PID 값 할당.
7. clone() 함수에 전달된 플래그 값에 따라 여러 자원 등을 복제하거나 공유. 스레드끼리는 이 자원을 공유하고, 그 외 경우는 개별사용하므로 이 단계에서 복제(플래그 값의 정보는 pdf p.17 참조)
    - 여러 자원 : 파일시스템 정보, 시그널 핸들러, 프로세스 주소 공간, 네임스페이스 등
8. 나머지 정리 작업을 수행하고 호출한 쪽에 새 자식 프로세스의 포인터 반환.

위 프로세스가 모두 성공했다면(= copy_process()가 성공적으로 동작했다면) 자식 프로세스를 깨워서 실행하고, 커널은 의도적으로 자식 프로세스를 먼저 실행.

이유? : 자식 프로세스는 바로 exec()함수를 호출하므로 부모 프로세스가 먼저 실행되면 주소 공간에 쓰기 작업이 생겨 COW작업을 막을 수 있음. 

vfork() 시스템 콜은 부모 프로세스의 페이지 테이블을 복사하지 않는다는걸 제외하고는 fork()와 같음. 대신, 자식 프로세스는 부모 프로세스의 주소 공간 속에서 별개 스레드 형태로 실행, 부모 프로세스는 자식 프로세스가 exec()를 호출하거나 종료할 때까지 대기. 자식 프로세스는 주소 공간의 내용을 바꿀 수 없음.

지금은 COW + 자식 프로세스 우선 실행하므로 vfork()로 부모 프로세스의 페이지 테이블을 복사하지 않는다는것 말고는 이점 없음. 만약 리눅스가 페이지 테이블 항목에 대해서도 COW기능을 제공하면, 이런 장점도 없어짐(패치로 이 기능을 제공해줌).

### 스레드 생성

다른 프로세스를 생성할 때와 같지만, clone()시스템 콜을 호출할 때 특정 자원을 공유하게 플래그 지정해주는게 차이점의 전부.

### 프로세스 종료(exit)

보통 프로세스 종료는 자발적으로 일어남(하지만, 프로세스가 처리할 수도, 무시할 수도 없는 시그널이나 예외를 만나는 경우는 비자발적으로 일어남). 프로세스가 준비되었을 때 exit()함수를 호출하거나, main() 반환시에 묵시적으로 exit()함수 호출. 이렇게 종료되면 프로세스가 가지고 있던 자원을 반납하고, 부모 프로세스에게 자식 프로세스가 종료되었다고 알려줌.

어떤 방식으로든 종료되면 kernel/exit.c에 정의된 do_exit()함수를 호출하는데, 그 방식은 아래 순서를 따름.

1. task_struct 구조체의 flags 항목에 PF_EXITING 플래그 설정.
2. del_timer_sync()함수를 호출해서 커널 타이머 제거. 정상 실행되었다면, 대기중인 타이머와 실행중인 타이머가 없다는 것을 보증함.
3. BSD 방식의 프로세스 정보 기록 기능을 사용한다면, acct_update_integrals()함수를 호출해 관련 정보를 기록
4. exit_mm() 함수를 호출해 가지고 있던 mm_struct를 반환. 이 주소공간이 공유되지 않다면 커널은 이 자원을 할당 해제.
5. exit_sem()호출. 프로세스가 만약 IPC 세마포어를 얻으려고 대기중이었다면, 이 시점에서 대기상태 해제.
6. exlt_files(), exlt_fs()함수를 호출해 관련 파일 서술자, 파일 시스템의 참조 횟수를 줄임. 참조 횟수가 0에 도달하면 해당 객체를 사용하는 프로세스가 없다는 의미이므로, 해당 자원을 반환.
7. 태스크의 종료 코드를 task_struct의 exit_code 항목에 저장. exit()함수에서 지정한 값이나, 커널의 종료 방식에 의해서 이 종료 코드 값이 결정됨.
8. exit_notify()를 호출해 부모 프로세스에게 시그널 전송, 해당 프로세스가 속한 스레드군의 다른 스레드나 init 프로세스를 자식 프로세스의 새로운 부모로 설정 task_struct 구조체의 exit_state 항목에 태스크 종료 상태를 EXIT_ZOMBIE로 설정(이유는 뒤에 설명)
9. schedule()함수를 호출해 새 프로세스로 전환(4장에서 추가 설명 있을예정).

이렇게 태스크와 관련된 모든 객체를 반환하고, 태스크는 더 이상 실행이 불가능한 EXIT_ZOMBIE상태로 전이. 종료된 태스크는 커널 스택, thread_info 구조체, task_struct 구조체만 빼고 전부 반환(부모 프로세스에 전달이 필요한 정보를 보관하기 위해). 만약 부모 프로세스가 이 정보를 굳이 필요로 하지 않는다면, 이마저도 다 반환됨.

### 프로세스 서술자 제거

프로세스 종료 작업과 프로세스 서술자를 제거하는 작업은 완전 분리된 별도의 작업(프로세스 종료 작업을 처리해도, 부모 프로세스에게 정보를 전달할 경우를 대비해 프로세스 서술자를 제거하지 않고 그대로 두기 때문. 이를 제거하려면 커널이 별도로 필요없다고 명시해줄 경우에 실행).

- wait() 계열 함수 : 함수를 호출한 프로세스의 동작을 자식 프로세스가 종료될 때까지 정지. 종료된 자식 프로세스의 PID를 반환하고, 종료된 자식 프로세스의 종료 코드를 저장할 포인터도 제공.

프로세스 서술자를 제거할 땐 release_task() 함수를 호출해서 제거. 그 작업은 아래 순서를 따름.

1. __exit_signal() → __unhash_process() → detach_pid() 함수를 차례대로 호출. 맨 마지막에 해당 프로세스를 pidhash와 태스크 리스트에서 제거.
2. __exit_signal() 함수는 남은 자원을 반환하고, 통계값과 기타 정보를 기록(어디에 하는지는 모름)
3. 만약, 종료된 프로세스가 해당 스레드군의 마지막 스레드였다면, 대표 스레드가 좀비가 된 것이므로 대표 스레드의 부모 프로세스에게 알림.
4. put_task_struct() 함수를 호출해서 프로세스의 커널 스택, thread_info 구조체가 들어있던 페이지 반환하고, task_struct 구조체가 들어있던 슬랩 캐시 반환.

이 과정을 통해서 프로세스 서술자와 해당 프로세스와 연관된 모든 자원이 해제됨.

만약, 부모가 존재하지 않는 태스크가 남는다면(= 부모 프로세스가 자식 프로세스보다 먼저 종료되고 뒤처리를 안한다면)?

영원히 좀비 프로세스로 남아서 시스템 메모리를 낭비함. 때문에, 부모 프로세스가 자식 프로세스보다 먼저 종료되면 반드시 다른 프로세스를 자식 프로세스의 부모로 지정해주어야 함. 종료된 프로세스의 스레드군의 다른 프로세스를 부모로 설정하던가, 여의치않으면 init 프로세스를 부모로 설정.

do_exit()는 exit_noitfy()를 호출, 여기서 forget_original_parent()함수 호출, 여기서 find_new_reaper()함수 호출. 이 마지막 함수에서 부모 프로세스 재지정.

→ 프로세스 계층 구조에서 탈락한 부분트리가 생성되는 것이므로, 태스크 큐에 적재하기위한 계층구조 탐색에서 발견되지 않으므로 계속 일을 할당받지 못하고 ZOMBIE상태로 남아 메모리 낭비.

### 커널 스레드

커널도 일부 동작을 백그라운드에서 실행하는 것이 좋은 경우가 간혹 있음.

- 커널 스레드 : 커널 공간에서만 존재하는 표준 프로세스

커널 스레드는 일반 프로세스와 다르게 주소 공간을 사용하지 않음(mm 포인터 = NULL). 커널 스레드는 커널 공간에서만 동작하므로 사용자 공간으로 컨택스트 스위칭이 일어나지 않음. 하지만, 정상 프로세스와 마찬가지로 스케줄링 및 선점 가능.

커널 스레드를 통해 대표적으로 flush, ksoftirqd 작업 수행.(이 둘이 각각 뭔지?)

커널 스레드는 다른 커널 스레드를 통해서만 만들 수 있고, kthreadd 커널 프로세스가 모든 커널 스레드를 만들어줌(=일반 프로세스의 init 프로세스와 비슷)

kthread 커널 프로세스도 clone()시스템 콜을 이요해서 새 태스크를 만듦. 처음 프로세스는 실행할 수 없는 상태로 만들어지고, wake_up_process() 함수를 통해 명시적으로 깨워줘야만 실행 가능. 

커널 스레드는 한번 시작되면 스스로 do_exit()함수를 호출하거나, 커널의 다른 부분에서 kthread_create()가 반환한 task_struct 구조체의 주소와 함께 kthread_stop() 함수를 호출할 때까지 계속 실행(= 커널의 다른 부분이 명시적으로 커널 스레드를 죽이는 경우)

## 질문 추가조사

### 슬랩?

슬랩 : 미리 할당해 놓은 작은 메모리 조각

슬랩 할당자 : 슬랩을 kmalloc요청에 따라 요청한 양에 가장 가까운 메모리 조각을 반환해줌.

e.g. 

1) 슬랩을 사용하지 않는 경우 - kmalloc를 이용해 16byte 요청, 기본 페이지는 4kb

kmalloc를 이용해 16byte 요청이 들어왔으므로, 할당하는 가장 작은 단위인 1개 페이지를 주어 4kb 할당. 

이때, 총 4096byte - 16byte = 4080byte는 이 요청자에게 할당되어있지만 사용하지 않아 메모리 낭비로 전락

2) 슬랩을 사용하는 경우 - kmalloc를 이용해 16byte 요청, 기본 페이지는 4kb, 다양한 크기의 슬랩이 할당되어 있음

이때, 요청한 16byte와 가장 가까운 32byte 크기의 슬랩을 사용할 수 있도록 제공.

슬랩 할당자 구조

- 슬랩 캐시 : 커널에서 자주 요청하는 크기에 대해 동적 메모리를 미리 확보하고 관리하는 주체
- 슬랩 오브젝트 : 슬랩 캐시가 할당해놓은 메모리 블록(malloc의 chunk와 유사)
- 슬랩 페이지 : 슬랩 오브젝트로 구성된 페이지

task_struct에서는 이를 어떻게 사용하는가?

프로세스를 생성할 때 마다 struct task_struct 구조체 크기만큼 메모리를 할당받기 때문에, 슬랩 할당자를 이용해 task_struct만큼 미리 할당받아 놓고 프로세스를 생성할 때 마다 이 메모리 공간을 제공해서 생성 시간 감소를 노릴 수 있음.

### 커널 주소 공간 / 커널 컨택스트 스위칭 방식?

커널 스레드 : 커널 공간에서 존재하는 스레드고, 관리 주체가 OS.

- 주소공간이 없다? : 프로세스의 주소 공간을 가리키는 mm 포인터가 NULL이라는 의미. 메모리를 크게 커널 공간과 사용자 공간으로 나눌 수 있는데, 여기서 “사용자 공간”에 할당된 커널 스레드의 주소 공간이 할당되지 않았다는 의미.
    - 사용자 주소 공간 : 각 응용 프로그램이 나누어 적재되고 사용되는 공간(통상 사용하는 메모리 공간은 이 공간을 말하는 것)
    - 커널 주소 공간 : 커널에 의해 배타적으로 사용되는 메모리 공간(커널 코드, 커널 데이터, 디바이스 드라이버 등이 상주)
    - 왜? : 커널 스레드는 어떤 “프로세스 안에 들어있는 스레드”가 아니므로, 자신만의 데이터 공간을 따로 점유하지 않음.
- 컨택스트 스위칭이 일어나지 않는다? : 커널 스레드들끼리 스위칭이 일어나지 않는다는 의미가 아니라, “커널 스레드 <> 유저 스레드간” 컨택스트 스위칭이 일어나지 않는다는 의미.

### list_for_each 함수

list_for_each 함수 원형

#define list_for_each(pos, head)

for (pos = (head)→next; pos ≠ (head); pos = pos→next)

list_for_each 적용 사례

list_for_each(list, &current→children) {

      task = list_entry(list, struct task_struct, sibling);

      //이제 task는 현재 프로세스의 자식 프로세스 중 하나를 가리킴

}

- 전달인자 : 현재 노드를 가리키는 포인터, 순회하기 원하는 리스트의 헤드를 가리키는 포인터

→ list_entry는 무엇?
list_entry 함수 원형

#define list_entry(ptr, type, member) {

((type *)((char *)(ptr)-(unsigned long)(&((type *)0)→member)))

- 목적 : linked list에서 link 정보를 구조체 안에 있는 변수에 넣고(원형에선 member), 이 변수들이 다른 구조체에 접근할 수 있도록 하는 것.
    - 실제로 리스트에서 다음 노드의 링크 변수에만 접근 가능(member)
- 원하는 것은 링크 변수가 아니라 링크 변수를 가진 구조체의 시작점이고, 이를 계산하는 매크로가 list_entry.
    - 가상의 구조체를 만들어서 링크 변수의 주소에서 링크 변수의 구조체 시작점 주소를 빼서 실제 구조체 실제 주소를 찾음(예제는 0을 구조체 타입으로 캐스팅한 것)
    

task_struct 구조

[https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=stonewat&logNo=100064820579](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=stonewat&logNo=100064820579)

pidhash 사용 이유?

pid는 태스크 리스트에 저장되어 있고, 프로세서가 이 pid를 액세스하기 위해서는 태스크 리스트를 탐색하면서 그 id를 찾는 방식으로 접근해야 함(pidhashtable이 없는 경우). 이때, 모든 list를 순회해야 하므로 시간복잡도를 계산하면 O(N)형태의 꼴로 나타남. 해서 pid를 그룹화하여(프로세스의 pid, 스레드 그룹의 리더 pid, 프로세스 그룹의 리더 pid 등) 이를 테이블로 나타내면, 특정 프로세스에 액세스할 때 pid를 테이블에서 바로 서칭하여 위치를 찾아낼 수 있으므로 사용함.